# -*- coding: utf-8 -*-
"""CSE422_Lab02_Genetic.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l-H0j7lbyxNtR62dDqz7gRP98SpuqGLj

## CSE422 lab: Genetic Algorithm

#### Genetic Algorithm Pseudo code:

**function** GENETIC-ALGORITHM( population, FITNESS-FN) **returns** an individual 
 
> **inputs:** population- a set of individuals/chromosomes; FITNESS-FN- a function that measures the fitness of an individual

>**repeat** 
new_population $\leftarrow$ empty set 
>>**for** $i=1$ **to** size ($ population$) **do**
$$
\begin{array}{l}
x \leftarrow \text { RANDOM-SELECTION }(\text { population, FITNESS-FN }) \\
y \leftarrow \text { RANDOM-SELECTION }(\text { population, FITNESS-FN }) \\
child  \leftarrow \operatorname{CROSSOVER}(x, y)
\end{array}
$$
>>>**if** (some_random_number < mutation_threshold) **then** child$\leftarrow$ MUTATE ( child ) 

>>>add child to new_population 

>>population $\leftarrow$ new_population 

>**until** some individual is fit enough, or enough time has elapsed

>**return** the best individual in population, according to FITNESS-FN

### Skeleton Code:

### Importing libraries
"""

import numpy as np

"""### Fitness function"""

def fitness(chromosome, n):

  '''calculates the fitness score of each
     of the individuals in the population
     
     returns a 1D numpy array: index referring to 
     ith individual in population, and value referring 
     to the fitness score.'''

  max_fitness=((n-1)*n)/2
  
  total_collision=0
  arr=chromosome
  #print(arr)
  matrix=np.zeros(shape=(n,n))
  #print(matrix)
  for j in range(n):
    a=arr[j]
    matrix[j][a] = 1 
    
  horizontal_collision=0 
  arr1=set(arr)
  horizontal_collision=len(arr)-len(arr1)

  #print(horizontal_collision)
  diagonal_collision=0

  starting_first_idx=n-2
  starting_second_idx=0
  initial_range=2 
  for j in range(n-1):
    queen=0
    first_idx=starting_first_idx
    second_idx=starting_second_idx
    
    for a in range(initial_range):
      if matrix[first_idx][second_idx]==1:
        queen+=1
      
      first_idx+=1
      second_idx+=1

    if queen>1:
      diagonal_collision+=queen-1
      
    initial_range+=1
    starting_first_idx+=-1

  starting_first_idx=0
  starting_second_idx=1
  initial_range=n-1
  for j in range(n-2):
    queen=0
    first_idx=starting_first_idx
    second_idx=starting_second_idx
    
    for a in range(initial_range):
      if matrix[first_idx][second_idx]==1:
        queen+=1
      first_idx+=1
      second_idx+=1

    if queen>1:
      diagonal_collision+=queen-1
      
    initial_range+=-1
    starting_second_idx+=1

  starting_first_idx=0
  starting_second_idx=1
  initial_range=2
  for j in range(n-1):
    queen=0
    first_idx=starting_first_idx
    second_idx=starting_second_idx
    
    for a in range(initial_range):
      if matrix[first_idx][second_idx]==1:
        queen+=1
      first_idx+=1
      second_idx+=-1

    if queen>1:
      diagonal_collision+=queen-1
      
    initial_range+=1
    starting_second_idx+=1
    
  starting_first_idx=1
  starting_second_idx=n-1
  initial_range=n-1
  for j in range(n-2):
    queen=0
    first_idx=starting_first_idx
    second_idx=starting_second_idx
    
    for a in range(initial_range):
      if matrix[first_idx][second_idx]==1:
        queen+=1
      first_idx+=1
      second_idx+=-1

    if queen>1:
      diagonal_collision+=queen-1
      
    initial_range+=-1
    starting_first_idx+=1

  total_collision=horizontal_collision+diagonal_collision

  
  return max_fitness-total_collision

def total_fitness(population,n):
  chrom_fit=[]

  for i in range(len(population)):
    arr=population[i]
    chrom_fit.append(fitness(arr,n))
  
  return chrom_fit

def probability(fit_list):
  prob_list=[]
  for i in range(len(fit_list)):
    prob_list.append(fit_list[i]/sum(fit_list))
  
  return prob_list

"""### Random Selection function

This built-in function might help to create the weighted random selection:

`numpy.random.choice(a, size, replace, p)` 

`p` are the weights of the individuals- value between 0 and 1; refers to the probability of each individual being selected.

`a` is the array

`size` how many samples to return

`replace = True`
"""

def select(population, fit):
  ''' take input:  population and fit
      fit contains fitness values of each of the individuals 
      in the population  
      
      return:  one individual randomly giving
      more weight to ones which have high fitness score'''
  arr=np.array(range(0,len(population)))
  a=np.random.choice(arr,1,True,fit)

  
  return population[a[0]]

"""### Crossover function


**function** CROSSOVER $(x, y)$ **returns** an individual 

>**inputs**: $x, y$  which are the parent individuals

>$n \leftarrow \mathrm{LENGTH}(x) ; c \leftarrow$ random number from 1 to $n$ 

>**return** APPEND(SUBSTRING $(x, 1, c),$ SUBSTRING $(y, c+1, n))$
"""

def crossover(x, y):
  '''take input: 2 parents - x, y. 
     Generate a random crossover point. 
     Append first half of x with second 
     half of y to create the child
     
     returns: a child chromosome'''
  arr = np.array(range(1,10))
  slice_point=np.random.choice(arr)
  x_first=x[0:slice_point]
  y_last=y[slice_point:len(x)]

  return np.concatenate((x_first,y_last))

"""###Mutation function"""

def mutate(child):
  '''take input: a child
     mutates a random 
     gene into another random gene
     
     returns: mutated child'''
  value=np.random.randint(0,len(child))
  index=np.random.randint(0,len(child))
  child[index]=value   

  return child

"""### Genetic Algorithm Function"""

def GA(population, n, mutation_threshold = 0.3):
  '''implement the pseudocode here by
     calling the necessary functions- Fitness, 
     Selection, Crossover and Mutation
     
     print: the max fitness value and the 
     chromosome that generated it which is ultimately 
     the solution board'''
  chromosome_arr=population
  child_fitness=([])
  max_fitness=((n-1)*n)/2
  fit_chromosome=([])
  generation=0
  while child_fitness != max_fitness:
    
    chrom_fitness=total_fitness(chromosome_arr,n)
    chrom_prob=probability(chrom_fitness)
    new_population=([[0]*n])
    child=([])
    for i in range(len(chromosome_arr)):
      x = select(chromosome_arr,chrom_prob)   
      y = select(chromosome_arr,chrom_prob)
      child = crossover(x,y)
      if np.random.random() < mutation_threshold:
        child = mutate(child)

      if fitness(child,n)==max_fitness:
        fit_chromosome=child
        break
      
      new_population = np.vstack((new_population,child))

    new_population=np.delete(new_population,0,axis=0)
    chromosome_arr=new_population
    child_fitness=fitness(child,n)
    generation+=1
    print(str(child_fitness)+" "+str(child)+" "+str(generation))
    
  return fit_chromosome

"""Running the Genetic Algorithm function"""

'''for 8 queen problem, n = 8'''
n = 8

'''start_population denotes how many individuals/chromosomes are there
  in the initial population n = 8'''
start_population = 10 

'''if you want you can set mutation_threshold to a higher value,
   to increase the chances of mutation'''
mutation_threshold = 0.3

'''creating the population with random integers between 0 to 7 inclusive
   for n = 8 queen problem'''
population = np.random.randint(0, n, (start_population, n))

'''calling the GA function'''
print(GA(population, n, mutation_threshold))

arr=([4,3,2,4,0])
arr1=set(arr)
print(fitness(arr,5))
print(arr1)